### 动态规划

````
 一句话：动态规划是利用空间换取时间，也就是说遍历计算时，我将之前的结果保存，在计算当前结果时直接取用。而不用再次遍历求和。
 因此，很容易理解状态转移方程是干什么的了。就是已知 A[k - 1] 值时，如何求解 A[k]。那么知道初始条件和计算顺序后，就能够迭代一遍将所有情况计算出。
 
 比如，我要求和最大的连续子序列。初始序列为 4、5、0、-2。
 这时我们暴力枚举的做法就是计算 4、4+5、4+5+0、4+5+0+(-2)、5、5+0、5+0+(-2)、0、0+(-2)、-2。
 可以看到有很多地方是重复的，比如4+5+0+(-2)就需要重新遍历该子序列求和。实际上我们可以将之前的4+5+0保存，然后计算。
 那我们就设一个A[]数组保存计算过的数据，arr[]是原数组,可以这样计算
 A[0]=arr[0]、A[1]=A[0]+arr[1]、A[2]=A[1]+arr[2]、A[3]=A[2]+arr[3]
 A[4]=arr[1]、A[5]=A[4]+arr[2]、A[6]=A[5]+arr[3]
 A[7]=arr[2]、A[8]=A[7]+arr[3]
 A[9]=arr[3]
 这样遍历到每种情况时，不必再遍历求和了，减小了时间复杂度，但仍不是最优方法，因为没有充分利用该题的条件。
 这时候可以通过保存计算过的数据 + 策略，继续优化。我每次只保留包含该元素的最大和。即A[X] = max{arr[x]、A[X-1]+arr[x]}
 A[0]=0、A[1]=max{A[0]+arr[1]、arr[1]}、A[2]=max{A[1]+arr[2]、arr[2]}、A[3]=max{A[2]+arr[3]、arr[3]} =》 4、9、9、7 =〉连续子序列最大和为 9.
 可见使用动态规划后，时间复杂度大大降低。
````
- 求最值型动态规划

1. 确定状态

- 最后一步（最优策略中使用的最后一枚硬币ak）
- 化成子问题（最少的硬币拼出更小的面值ak-1），这样可以更快写出状态方程

2. 转移方程（根据子问题定义直接得到）

- f [x] = min { f [x-2] + 1, f [x-5] + 1, f [x-7] + 1 }

3. 确定初始条件和边界情况（细心，考虑周全）

- f [0] = 0，如果不能拼接出X，f[X] = 正无穷

4. 确定计算顺序

- f[0] f[1] ...
