### 动态规划

````
 一句话：动态规划是利用空间换取时间，也就是说遍历计算时，我将之前的结果保存，在计算当前结果时直接取用。而不用再次遍历求和。
 因此，很容易理解状态转移方程是干什么的了。就是已知 A[k - 1] 值时，如何求解 A[k]。那么知道初始条件和计算顺序后，就能够迭代一遍将所有情况计算出。
 
 比如，我要求和最大的连续子序列。初始序列为 4、5、0、-2。
 这时我们暴力枚举的做法就是计算 4、4+5、4+5+0、4+5+0+(-2)、5、5+0、5+0+(-2)、0、0+(-2)、-2。
 可以看到有很多地方是重复的，比如4+5+0+(-2)就需要重新遍历该子序列求和。实际上我们可以将之前的4+5+0保存，然后计算。
 那我们就设一个A[]数组保存计算过的数据，arr[]是原数组,可以这样计算
 A[0]=arr[0]、A[1]=A[0]+arr[1]、A[2]=A[1]+arr[2]、A[3]=A[2]+arr[3]
 A[4]=arr[1]、A[5]=A[4]+arr[2]、A[6]=A[5]+arr[3]
 A[7]=arr[2]、A[8]=A[7]+arr[3]
 A[9]=arr[3]
 这样遍历到每种情况时，不必再遍历求和了，减小了时间复杂度，但仍不是最优方法，因为没有充分利用该题的条件。
 这时候可以通过保存计算过的数据 + 策略，继续优化。我每次只保留包含该元素的最大和。即A[X] = max{arr[x]、A[X-1]+arr[x]}
 A[0]=0、A[1]=max{A[0]+arr[1]、arr[1]}、A[2]=max{A[1]+arr[2]、arr[2]}、A[3]=max{A[2]+arr[3]、arr[3]} =》 4、9、9、7 =〉连续子序列最大和为 9.
 可见使用动态规划后，时间复杂度大大降低。
 -------------------------------------------------------------------------------------------------------------
 上一个问题，为何能够使用策略，因为子问题有最优解，而该最优解又是下一步计算的关键，因此只需要保留每一步的最优解就可以了。
 而有的题每个子问题没有最优解，那么这时候只能保留每一步的计算结果，下一步计算时遍历上一步结果并保留符合条件的结果。实际上就是暴力求解，也就是记忆搜索。
````
### 求最值型动态规划

1. 确定状态

- 最后一步（最优策略中使用的最后一枚硬币ak）、要确定数组的含义，是用来保存什么的
- 化成子问题（最少的硬币拼出更小的面值ak-1），这样可以更快写出状态方程

2. 转移方程（根据子问题定义直接得到）

- f [x] = min { f [x-2] + 1, f [x-5] + 1, f [x-7] + 1 }

3. 确定初始条件和边界情况（细心，考虑周全）

- f [0] = 0，如果不能拼接出X，f[X] = 正无穷

4. 确定计算顺序

- f[0] f[1] ...
****
### 序列型动态规划

- 出现如下字段： ...前 n 个...方式数/最小/可行性

- 思考还是从最后一个原子操作分析。发现需要前N-1栋房子的最优策略中，房子N-2的颜色。
  那么就加一个状态，求假设N-2在不同状态下的最优解。然后再比较不同状态下最优解的最优解。
  
- 序列加状态。真的真的真的真的真的很重要！！！！！！最后再按照状态遍历取极值

- 注意序列型动态规划与坐标型动态规划区别。序列型动态规划转移方程 f[0] 一般表示前 0 个元素最值、总值等等。
因此一般为 0。而坐标型动态规划 f[0] 一般表示数组中第0个位置这个元素。

****
### 坐标型动态规划

- 给定一个序列或者网格（给序列的不一定是坐标型，也可能是序列型）

- 需要找到序列中某个/某些子序列或网格中的某条路径。比如某种性质最大/最小。计数。存在性

- 动态规划方程f[i]的下标 i 表示以 ai 结尾的满足条件的结果。f[i][j]的下标 i,j 表示以 (i,j) 结尾的满足条件的结果。
比如：f[i][j] 是从（0，0）到（i，j）满足条件走过路径的最小值。还有求个数、是否存在等条件。